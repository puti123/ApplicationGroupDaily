[toc]
## 泛型
泛型用于解决安全问题，是一个类型安全机制
- 泛型格式：通过<>来定义要操作的引用数据类型.     
通常在集合框架中很常见，只要见到<>就要定义泛型，<>就是用来接收类型的，当使用集合时，将集合中要存储的数据类型作为参数传递到<>
### 泛型类
```
class Utils<QQ>//定义泛型类
{
    private QQ q;
    public void setObject(QQ q)
    {
        this.q=q;
    }
}
main()
{
    Utils<Worker> u = new Utils<Worker>();//将Worker类传给QQ
}
```
当类中要操作的引用数据不确定的时候，早期定义Object来完成扩展，现在定义泛型类来完成扩展，只要<T>一确定就只操作T类对象，
### 泛型方法
泛型类定义的泛型，在整个类中有效，如果被方法使用，那泛型类的对象明确要操作的具体类型后，所有要操作的类型就固定了。    
为了让不同方法可以操作不同的类型，而且类型还不确定，那么可以将泛型定义在方法上  
eg.
```
class Demo
{
    private T t;
    public <T> void set(T t)
    {
        this.t = t;
    }
}
```
泛型定义在方法上的特殊之处：静态方法不可以访问类上定义的泛型，如果静态方法操作的应用数据不确定，可以将泛型定义在方法上。
参考代码：day15.GenericDEmo4
### 泛型限定
参考代码：day15.GenericDemo6
<?>：?为占位符（通配符），类型不明确
<? extends E>：可以接收E类或E的子类型
<? super E>：可以接收E类型或E的父类型（GenericDemo7） 

